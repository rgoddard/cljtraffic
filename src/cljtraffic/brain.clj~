(ns cljtraffic.brain
  (:import (javax.swing JFrame JPanel)
	   (java.awt Color Graphics)
	   (java.awt.image BufferedImage)))


(defn fmap [f coll] (doall (map f coll)))
(def dim-board [60 60])
(def dim-screen [400 400])
(def dim-scale (vec (map / dim-screen dim-board)))

(defn render-cell [#^Graphics g cell]
  (let [[state x y] cell
	x (inc (* x (dim-scale 0)))
	y (inc (* y (dim-scale 1)))]
    (doto g
      (.setColor (if (= state :dying) Color/GRAY Color/WHITE))
      (.fillRect x y (dec (dim-scale 0)) (dec (dim-scale 1))))))

(defn render [g img bg stage]
  (.setColor bg Color/BLACK)
  (.fillRect bg 0 0 (dim-screen 0) (dim-screen 1))
  (fmap (fn [col]
	  (fmap #(when (not= :off (first %))
		   (render-cell bg %)) col)) stage)
  (.drawImage g img 0 0 nil))


(def board
     (for [x (range (dim-board 0))]
       (for [y (range (dim-board 1))]
         [(if (< 40 (rand-int 100)) :on :off) x y])))

(defn torus-window [coll]
  (partition 3 1 (concat [(last coll)] coll [(first coll)])))

(defn activate-neighbors [above [left _ right] below]
  (count
   (filter #(= :on (first %))
	   (concat above [left right] below))))
		   
(defn rules [above current below]
  (let [[self x y] (second current)
	num-neighbors (activate-neighbors above current below)]
    (cond
     (< num-neighbors 2) [:off x y]
     (> num-neighbors 3) [:off x y]
     (and (= :off self) (= num-neighbors 3)) [:on x y]
     :else [self x y])))


(defn rulesa [above current below]
  (let [[self x y] (second current)]
    (cond
     (= :on self) [:dying x y]
     (= :dying self) [:off x y]
     (= 2 (activate-neighbors above current below)) [:on x y]
     :else [:off x y])))


(defn step1 [board]
  (doall
   (map (fn [window]
          (apply #(doall (apply map rules %&))
                 (doall (map torus-window window))))

	(torus-window board))))

(defn step [board]
  (doall
   (pmap (fn [window]
          (apply #(doall (apply map rules %&))
                 (doall (map torus-window window))))
	 (torus-window board))))

(defn activity-loop [surface stage]
  (while true
    (swap! stage step)
    (.repaint surface)))

(defn start []
  (let [stage (atom board)
	frame (JFrame.)
	img (BufferedImage. (dim-screen 0) (dim-screen 1) (BufferedImage/TYPE_INT_ARGB))
	bg (.getGraphics img)
	panel (doto (proxy [JPanel] [] (paint [g] (render g img bg @stage))))]
    (doto frame (.add panel) .pack (.setSize (dim-screen 0) (dim-screen 1)) .show
	  (.setDefaultCloseOperation JFrame/EXIT_ON_CLOSE))
    (future (activity-loop panel stage))))